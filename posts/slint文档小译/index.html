<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Slint文档小译 - 傻鸟的窝</title><meta name="Description" content="基于 LoveIt 摆烂搭建"><meta property="og:title" content="Slint文档小译" />
<meta property="og:description" content="Module slint::docs::mcu 微控制器上的 Slint 下文将介绍如何在裸机环境下使用 Slint 在微控制器 (MCU) 上开发用户界面。 准备 用 Rust 编写可在微控制器上运行的应用程序需要几个条件： 安装 Rust 工" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-22T16:13:53+08:00" />
<meta property="article:modified_time" content="2023-11-22T16:13:53+08:00" /><meta property="og:site_name" content="Lucky Ling" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Slint文档小译"/>
<meta name="twitter:description" content="Module slint::docs::mcu 微控制器上的 Slint 下文将介绍如何在裸机环境下使用 Slint 在微控制器 (MCU) 上开发用户界面。 准备 用 Rust 编写可在微控制器上运行的应用程序需要几个条件： 安装 Rust 工"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/" /><link rel="prev" href="https://dinduck.github.io/posts/c%CE%BBash/" /><link rel="next" href="https://dinduck.github.io/posts/nixos%E5%AE%89%E8%A3%85/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Slint文档小译",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/dinduck.github.io\/posts\/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91\/"
        },"genre": "posts","wordcount":  3650 ,
        "url": "https:\/\/dinduck.github.io\/posts\/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91\/","datePublished": "2023-11-22T16:13:53+08:00","dateModified": "2023-11-22T16:13:53+08:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "Lucky Ling"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="傻鸟的窝">My cool site</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="傻鸟的窝">My cool site</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Slint文档小译</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>Lucky Ling</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2023-11-22">2023-11-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;3650 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;8 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#微控制器上的-slint">微控制器上的 <code>Slint</code></a></li>
    <li><a href="#准备">准备</a></li>
    <li><a href="#修改-cargotoml">修改 <code>Cargo.toml</code></a></li>
    <li><a href="#修改-buildrs">修改 <code>build.rs</code></a></li>
    <li><a href="#应用结构">应用结构</a></li>
    <li><a href="#platform-特征"><code>Platform</code> 特征</a></li>
    <li><a href="#事件循环">事件循环</a></li>
    <li><a href="#渲染">渲染</a></li>
    <li><a href="#渲染至缓冲区">渲染至缓冲区</a></li>
    <li><a href="#逐行渲染">逐行渲染</a></li>
    <li><a href="#示例实现">示例实现</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="module-slintdocsmcu">Module slint::docs::mcu</h1>
<h2 id="微控制器上的-slint">微控制器上的 <code>Slint</code></h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://s2.loli.net/2023/11/22/dUqYtIADeZ8pHRz.png"
        data-srcset="https://s2.loli.net/2023/11/22/dUqYtIADeZ8pHRz.png, https://s2.loli.net/2023/11/22/dUqYtIADeZ8pHRz.png 1.5x, https://s2.loli.net/2023/11/22/dUqYtIADeZ8pHRz.png 2x"
        data-sizes="auto"
        alt="https://s2.loli.net/2023/11/22/dUqYtIADeZ8pHRz.png"
        title="image.png" /></p>
<p>下文将介绍如何在裸机环境下使用 Slint 在微控制器 (MCU) 上开发用户界面。</p>
<h2 id="准备">准备</h2>
<p>用 Rust 编写可在微控制器上运行的应用程序需要几个条件：</p>
<ul>
<li>安装 Rust 工具链，以便交叉编译到目标架构。</li>
<li>找到并选择正确的硬件抽象层（HAL）crate 和驱动程序，并在 <code>Cargo.toml</code> 中添加。</li>
<li>安装用于烧录和调试的工具</li>
</ul>
<p>我们建议您阅读 <a href="https://docs.rust-embedded.org/book/" target="_blank" rel="noopener noreffer ">Rust Embedded Book</a>以及<a href="https://github.com/rust-embedded/awesome-embedded-rust" target="_blank" rel="noopener noreffer ">Awesome Embedded Rust</a> 列表中的各种crate 、工具和文档。这些资源可以指导你完成初始设置。许多资源都包含一个 &ldquo;hello world &ldquo;示例，可帮助您开始使用设备。</p>
<p>在裸机和 <code>#![no_std]</code> 的环境下， Slint需要一个全局的内存分配器。</p>
<p><em><strong>在 <code>#![no_std]</code> 下没有 <code>panic_handler</code> 和 <code>allocator</code> ， 前者用于 <code>panic</code>, 后者被 <code>Box</code> 等需要在堆上分配内存。</strong></em></p>
<p>以下各节假定您的设置已完成，并且在 MCU 上运行了非图形骨架 Rust 程序。</p>
<p>根据下面的步骤设置， 最后能在微控制器上运行非图形框架的 Rust 程序。</p>
<h2 id="修改-cargotoml">修改 <code>Cargo.toml</code></h2>
<p>首先，使用 <code>cargo</code> 命令在 <code>Cargo.toml</code> 中添加 <code>slint</code> 和 <code>slint-build</code> crates 的依赖关系：</p>
<p>想这样添加 <code>slint</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Bash" data-lang="Bash"><span class="line"><span class="cl">cargo add slint@1.3.0 --no-default-features --features <span class="s2">&#34;compat-1-2 unsafe-single-threaded libm&#34;</span>
</span></span></code></pre></div><p><code>slint</code> crate 的默认功能是由托管环境定制的，其中包括 &ldquo;std &ldquo;功能。在裸机环境中，需要禁用默认功能。</p>
<p>在上面的代码段中，选择了三个特征：</p>
<ul>
<li><code>compat-1-2</code>: 我们在禁用默认功能时选择了这一功能。有关详细解释，请参阅我们的博客文章 <a href="https://slint.dev/blog/rust-adding-default-cargo-feature.html" target="_blank" rel="noopener noreffer ">&rdquo;# Adding default cargo features without breaking Semantic Versioning&rdquo;</a></li>
<li><code>unsafe-single-threaded</code>: Slint 内部使用 Rust 的 <code>thread_local!</code> 宏来存储全局数据。该宏仅在 Rust 标准库（std）中可用，在裸机环境中不可用。作为后备方案，<code>unsafe-single-threaded</code> 功能会将 Slint 改为使用不安全静态存储。这样，你就能保证只从单线程而不是中断处理程序中使用 Slint API。</li>
<li><code>libm</code>: 我们选择此功能是为了使用 <a href="https://crates.io/crates/libm" target="_blank" rel="noopener noreffer "><code>libm</code></a> crate 为浮点运算提供特质和函数。它们通常由 Rust 标准库 (std) 提供，但在裸机环境中无法使用。</li>
</ul>
<p>如果您发现即使在禁用的情况下，您的依赖程序仍在尝试使用 <code>std</code> 构建，那么可能有必要在 Cargo.toml 中启用 <a href="https://doc.rust-lang.org/cargo/reference/features.html#feature-resolver-version-2" target="_blank" rel="noopener noreffer "><code>Feature resolver version 2</code></a>。这是使用 Rust 2021 版时的默认设置，但使用工作区时则不是。</p>
<p>然后将 <code>slint-build</code> crate 添加为构建依赖项：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Bash" data-lang="Bash"><span class="line"><span class="cl">cargo add --build slint-build@1.3.0
</span></span></code></pre></div><p>示例参考：这些是您的 Cargo.toml 文件的相关部分，可随时使用 Slint：</p>
<pre tabindex="0"><code>[package]
## ...
## Edition 2021 or later enables the feature resolver version 2.
edition = &#34;2021&#34;

[dependencies]
## ... your other dependencies

[dependencies.slint]
version = &#34;1.3.0&#34;
default-features = false
features = [&#34;compat-1-2&#34;, &#34;unsafe-single-threaded&#34;, &#34;libm&#34;]
[build-dependencies]
slint-build = &#34;1.3.0&#34;
</code></pre><h2 id="修改-buildrs">修改 <code>build.rs</code></h2>
<p>接下来，使用 <code>slint-build</code> crate 编写编译脚本，将 <code>.slint</code> 文件编译为 Rust 代码，以便嵌入程序二进制文件：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">slint_build</span>::<span class="n">compile_with_config</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="s">&#34;ui/main.slint&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">slint_build</span>::<span class="n">CompilerConfiguration</span>::<span class="n">new</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">embed_resources</span><span class="p">(</span><span class="n">slint_build</span>::<span class="n">EmbedResourcesKind</span>::<span class="n">EmbedForSoftwareRenderer</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>使用 <code>slint_build::EmbedResourcesKind::EmbedForSoftwareRenderer</code> 配置选项，告诉 Slint 编译器在二进制文件中嵌入图像和字体，其格式应适合我们将要使用的基于软件的渲染器。</p>
<h2 id="应用结构">应用结构</h2>
<p>通常情况下，托管环境中的图形应用程序至少有三种不同的任务：</p>
<ul>
<li>从操作系统 API 接收用户输入</li>
<li>通过执行特定应用计算对输入做出反应</li>
<li>使用独立于设备的操作系统应用程序接口，渲染更新的用户界面并将其显示在屏幕上。</li>
</ul>
<p>操作系统提供了一个事件循环来连接和安排这些任务。Slint 实现了接收用户输入并将其转发到用户界面层，以及将用户界面呈现到屏幕上的任务。</p>
<p>在裸机环境中，您有责任替换和连接操作系统提供的功能：</p>
<ul>
<li>选择允许您初始化操作外设（如触摸输入或显示控制器）的芯片的 crate。如果没有 crate，您可能需要开发自己的驱动程序。</li>
<li>通过查询外设输入、将输入转入应用程序的计算模块以及指示 Slint 渲染用户界面，自行驱动事件循环。</li>
</ul>
<p>在 Slint 中，完成这些任务需要使用两个主要 API：<code>slint::platform::Platform</code> 特征和 <code>slint::Window</code> 结构。在下面的章节中，我们将介绍如何使用它们以及如何将它们集成到事件循环中。</p>
<h2 id="platform-特征"><code>Platform</code> 特征</h2>
<p><code>slint::platform::Platform</code> 特征定义了 Slint 与通常由操作系统和窗口系统提供的平台 API 之间的接口。</p>
<p>在构建 Slint 应用程序之前，您需要提供该特性的最小实现，并调用 <code>slint::platform::set_platform</code>。</p>
<p>这种最低限度的实施需要涵盖两个功能：</p>
<ul>
<li><code>fn create_window_adapter(&amp;self) -&gt; Result&lt;Rc&lt;dyn WindowAdapter + 'static&gt;, PlatformError&gt;;</code>:执行此函数可返回 <code>WindowAdapter</code> 特征的实现，该特性将与您创建的 Slint 组件相关联。我们提供了一个方便的结构  <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.MinimalSoftwareWindow.html" title="struct slint::platform::software_renderer::MinimalSoftwareWindow" target="_blank" rel="noopener noreffer "><code>slint::platform::software_renderer::MinimalSoftwareWindow</code></a> 实现了这一特征。</li>
<li><code>fn duration_since_start(&amp;self) -&gt; Duration</code>: 为使 <code>.slint</code> 设计文件中的动画能正确更改属性，Slint 需要知道两个渲染帧之间经过了多少时间。在裸机环境中，你需要提供一个时间源。通常情况下，设备的 HAL crate 会为此提供一个系统定时器应用程序接口（system timer API），您可以在您的输入中对其进行查询。</li>
</ul>
<p>您可以重写该特征的更多函数，例如处理调试输出、委托事件循环或在多线程环境中传递事件。</p>
<p>使用 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.MinimalSoftwareWindow.html" target="_blank" rel="noopener noreffer "><code>MinimalSoftwareWindow</code></a> 的 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/trait.Platform.html" target="_blank" rel="noopener noreffer "><code>Platform</code></a> 特性的典型最小实现如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="cp">#![no_std]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">alloc</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">alloc</span>::<span class="p">{</span><span class="n">rc</span>::<span class="n">Rc</span><span class="p">,</span><span class="w"> </span><span class="n">boxed</span>::<span class="nb">Box</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">use</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="p">{</span><span class="n">Platform</span><span class="p">,</span><span class="w"> </span><span class="n">software_renderer</span>::<span class="n">MinimalSoftwareWindow</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">slint</span>::<span class="fm">include_modules!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">MyPlatform</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">window</span>: <span class="nc">Rc</span><span class="o">&lt;</span><span class="n">MinimalSoftwareWindow</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// optional: some timer device from your device&#39;s HAL crate
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">timer</span>: <span class="nc">hal</span>::<span class="n">Timer</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ... maybe more devices
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="w"> </span><span class="n">Platform</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyPlatform</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">create_window_adapter</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Rc</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">WindowAdapter</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">slint</span>::<span class="n">PlatformError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Since on MCUs, there can be only one window, just return a clone of self.window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// We&#39;ll also use the same window in the event loop.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">clone</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">duration_since_start</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">core</span>::<span class="n">time</span>::<span class="n">Duration</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">core</span>::<span class="n">time</span>::<span class="n">Duration</span>::<span class="n">from_micros</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">get_time</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// optional: You can put the event loop there, or in the main function, see later
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">fn</span> <span class="nf">run_event_loop</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="n">slint</span>::<span class="n">PlatformError</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="fm">todo!</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// #[hal::entry]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Initialize the heap allocator, peripheral devices and other things.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Initialize a window (we&#39;ll need it later).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MinimalSoftwareWindow</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Default</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">set_platform</span><span class="p">(</span><span class="nb">Box</span>::<span class="n">new</span><span class="p">(</span><span class="n">MyPlatform</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">window</span>: <span class="nc">window</span><span class="p">.</span><span class="n">clone</span><span class="p">(),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">timer</span>: <span class="nc">hal</span>::<span class="n">Timer</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">}))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Setup the UI.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ui</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MyUI</span>::<span class="n">new</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ... setup callback and properties on `ui` ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Make sure the window covers our entire screen.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">window</span><span class="p">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">slint</span>::<span class="n">PhysicalSize</span>::<span class="n">new</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="w"> </span><span class="mi">240</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ... start event loop (see later) ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="事件循环">事件循环</h2>
<p>有了 <code>Platform</code>，就可以编写主循环事件来驱动所有不同的任务。</p>
<p>您可以从两个选项中进行选择：</p>
<ul>
<li>您可以实现 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/trait.Platform.html#method.run_event_loop" target="_blank" rel="noopener noreffer "><code>slint::platform::Platform::run_event_loop</code></a>：如果你想以类似桌面平台的方式启动事件循环，可以使用该函数，使用组件的 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/trait.ComponentHandle.html#tymethod.run" target="_blank" rel="noopener noreffer "><code>run()</code></a> 函数，或者使用 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/fn.run_event_loop.html" target="_blank" rel="noopener noreffer "><code>slint::run_event_loop()</code></a>。这两个函数都将调用你的 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/trait.Platform.html#method.run_event_loop" target="_blank" rel="noopener noreffer "><code>slint::platform::Platform::run_event_loop</code></a> 的实现。</li>
<li>执行循环 <code>loop { ...}</code> 直接在主函数中执行：这被称为超级循环架构，常见于在 MCU 裸机环境中运行的程序。它允许您初始化设备外设并访问它们，而无需将它们移至 <code>Platform</code> 实现中。</li>
</ul>
<p>使用 Slint 的典型超级循环结合了查询输入驱动程序、应用程序特定计算、渲染以及可能使设备进入低功耗睡眠状态等任务。下面是一个示例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">MinimalSoftwareWindow</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MinimalSoftwareWindow</span>::<span class="n">new</span><span class="p">(</span><span class="nb">Default</span>::<span class="n">default</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Let Slint run the timer hooks and update animations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">update_timers_and_animations</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Check the touch screen or input device using your driver.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">check_for_touch_event</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// convert the event from the driver into a `slint::platform::WindowEvent`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// and pass it to the window.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">window</span><span class="p">.</span><span class="n">dispatch_event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ... maybe some more application logic ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Draw the scene if something needs to be drawn.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">window</span><span class="p">.</span><span class="n">draw_if_needed</span><span class="p">(</span><span class="o">|</span><span class="n">renderer</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// see next section about rendering.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="fm">todo!</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// Try to put the MCU to sleep
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">window</span><span class="p">.</span><span class="n">has_active_animations</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">duration_until_next_timer_update</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// ... schedule a timer interrupt in `duration` ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">hal</span>::<span class="n">wfi</span><span class="p">();</span><span class="w"> </span><span class="c1">// Wait for interrupt
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="渲染">渲染</h2>
<p>在台式机和嵌入式环境中，Slint 通常使用操作系统提供的应用程序接口，利用 GPU 渲染用户界面。相比之下，大多数 MCU 都没有 GPU。取而代之的是软件渲染，所有渲染都由 CPU 上的软件完成。Slint 为这项任务提供了软件渲染器（SoftwareRenderer）。</p>
<p>在前面的示例中，我们实例化了一个 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.MinimalSoftwareWindow.html" target="_blank" rel="noopener noreffer "><code>slint::platform::software_renderer::MinimalSoftwareWindow</code></a> 结构。该结构体实现了<code> slint::platform::WindowAdapter</code> 特性，同时还持有一个 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.SoftwareRenderer.html" target="_blank" rel="noopener noreffer "><code>slint::platform::software_renderer::SoftwareRenderer</code></a> 的句柄。您可以通过 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.MinimalSoftwareWindow.html#method.draw_if_needed" target="_blank" rel="noopener noreffer "><code>draw_if_needed()</code></a> 函数的回调参数访问它。根据微控制器的 RAM 容量和所连接的屏幕类型，您可以选择两种不同的方法来使用渲染器：</p>
<ul>
<li>如果有足够的 RAM 来分配整个屏幕（也称为帧缓冲区）的一份甚至两份副本，请使用 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.SoftwareRenderer.html#method.render" target="_blank" rel="noopener noreffer "><code>SoftwareRenderer::render()</code></a> 函数。</li>
<li>使用 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.SoftwareRenderer.html#method.render_by_line" target="_blank" rel="noopener noreffer "><code>SoftwareRenderer::render_by_line()</code></a> 函数逐行渲染整个用户界面，并通常通过 SPI 将每行像素发送到屏幕。这至少需要分配足够的 RAM 来存储一行像素。</li>
</ul>
<p>通过这两种方法，Slint 会将图像渲染到提供的缓冲区中，缓冲区是实现 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/trait.TargetPixel.html" target="_blank" rel="noopener noreffer "><code>slint::platform::software_renderer::TargetPixel</code></a> 特性的类型的片段。为方便起见，Slint 提供了 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/type.Rgb8Pixel.html" target="_blank" rel="noopener noreffer "><code>slint::Rgb8Pixel</code></a> 和 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/struct.Rgb565Pixel.htm" target="_blank" rel="noopener noreffer "><code>slint::platform::software_renderer::Rgb565Pixel</code></a> 的实现。</p>
<h2 id="渲染至缓冲区">渲染至缓冲区</h2>
<p>下面的示例使用双缓冲并在两个缓冲区之间交换。这需要图形驱动程序获取当前显示的帧缓冲区（也称为前缓冲区）的地址。然后，一个专用芯片负责从 RAM 读取并将内容传输到连接的屏幕上，CPU 不会有任何干扰。与此同时，Slint 会将内容渲染到第二个缓冲区，即后缓冲区。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">Rgb565Pixel</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// In this example, we have two buffer: one is currently displayed, and we are
</span></span></span><span class="line"><span class="cl"><span class="c1">// rendering into the second one. Hence we use `RepaintBufferType::SwappedBuffers`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">MinimalSoftwareWindow</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">RepaintBufferType</span>::<span class="n">SwappedBuffers</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="no">DISPLAY_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">320</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="no">DISPLAY_HEIGHT</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">240</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">Rgb565Pixel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="no">DISPLAY_WIDTH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">DISPLAY_HEIGHT</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">Rgb565Pixel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="no">DISPLAY_WIDTH</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">DISPLAY_HEIGHT</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// ... configure the screen driver to use buffer1 or buffer2 ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// ... rest of initialization ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">currently_displayed_buffer</span><span class="w"> </span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">work_buffer</span><span class="w"> </span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="c1">// Draw the scene if something needs to be drawn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">window</span><span class="p">.</span><span class="n">draw_if_needed</span><span class="p">(</span><span class="o">|</span><span class="n">renderer</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// The screen driver might be taking some time to do the swap. We need to wait until
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// work_buffer is ready to be written in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="n">is_swap_pending</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Do the rendering!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">renderer</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">work_buffer</span><span class="p">,</span><span class="w"> </span><span class="no">DISPLAY_WIDTH</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// tell the screen driver to display the other buffer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">swap_buffers</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Swap the buffer references for our next iteration
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="c1">// (this just swap the reference, not the actual data)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">core</span>::<span class="n">mem</span>::<span class="n">swap</span>::<span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="n">_</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">work_buffer</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">currently_displayed_buffer</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="逐行渲染">逐行渲染</h2>
<p>在逐行渲染用户界面时，您需要实现 <a href="https://slint.dev/releases/1.3.0/docs/rust/slint/platform/software_renderer/trait.LineBufferProvider.html" target="_blank" rel="noopener noreffer "><code>LineBufferProvider</code></a> 特性。它在 Slint 和你的代码之间定义了一个双向接口，用于向屏幕发送线条：</p>
<ul>
<li>该特特性的相关 <code>TargetPixel</code> 类型可让 Slint 知道如何创建和处理像素。至于如何在设备中准确表示像素以及如何混合像素，这仍是您的具体实现细节。</li>
<li>特性的 <code>process_line</code> 函数会在可以渲染某一行时通知您，并提供一个回调函数，您可以调用该函数为给定的行填充像素片。</li>
</ul>
<p>下面的示例定义了一个 <code>DisplayWrapper</code> 结构：它将实现 <a href="https://lib.rs/embedded-graphics" target="_blank" rel="noopener noreffer "><code>embedded_graphics</code></a> 特性的屏幕驱动程序与 Slint 的 <code>Rgb565Pixel</code> 类型连接起来，以实现 <code>LineBufferProvider</code> 特性。一行的像素通过调用 <a href="https://docs.rs/embedded-graphics/0.7.1/embedded_graphics/draw_target/trait.DrawTarget.html" target="_blank" rel="noopener noreffer "><code>DrawTarget::fill_contiguous</code></a> 函数发送到屏幕。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Rust" data-lang="Rust"><span class="line"><span class="cl"><span class="k">use</span><span class="w"> </span><span class="n">embedded_graphics_core</span>::<span class="p">{</span><span class="n">prelude</span>::<span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">primitives</span>::<span class="n">Rectangle</span><span class="p">,</span><span class="w"> </span><span class="n">pixelcolor</span>::<span class="n">raw</span>::<span class="n">RawU16</span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">struct</span> <span class="nc">DisplayWrapper</span><span class="o">&lt;</span><span class="na">&#39;a</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">display</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">line_buffer</span>: <span class="kp">&amp;</span><span class="na">&#39;a</span> <span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">Rgb565Pixel</span><span class="p">],</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span>: <span class="nc">DrawTarget</span><span class="o">&lt;</span><span class="n">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">embedded_graphics_core</span>::<span class="n">pixelcolor</span>::<span class="n">Rgb565</span><span class="o">&gt;&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">LineBufferProvider</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">DisplayWrapper</span><span class="o">&lt;</span><span class="nb">&#39;_</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">type</span> <span class="nc">TargetPixel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">Rgb565Pixel</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">fn</span> <span class="nf">process_line</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">line</span>: <span class="kt">usize</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">range</span>: <span class="nc">core</span>::<span class="n">ops</span>::<span class="n">Range</span><span class="o">&lt;</span><span class="kt">usize</span><span class="o">&gt;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">render_fn</span>: <span class="nc">impl</span><span class="w"> </span><span class="nb">FnOnce</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="p">[</span><span class="bp">Self</span>::<span class="n">TargetPixel</span><span class="p">]),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Render into the line
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="n">render_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">line_buffer</span><span class="p">[</span><span class="n">range</span><span class="p">.</span><span class="n">clone</span><span class="p">()]);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// Send the line to the screen using DrawTarget::fill_contiguous
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">display</span><span class="p">.</span><span class="n">fill_contiguous</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">&amp;</span><span class="n">Rectangle</span>::<span class="n">new</span><span class="p">(</span><span class="n">Point</span>::<span class="n">new</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">),</span><span class="w"> </span><span class="n">Size</span>::<span class="n">new</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">line_buffer</span><span class="p">[</span><span class="n">range</span><span class="p">.</span><span class="n">clone</span><span class="p">()].</span><span class="n">iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">p</span><span class="o">|</span><span class="w"> </span><span class="n">RawU16</span>::<span class="n">new</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="mi">0</span><span class="p">).</span><span class="n">into</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">).</span><span class="n">map_err</span><span class="p">(</span><span class="nb">drop</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// Note that we use `ReusedBuffer` as parameter for MinimalSoftwareWindow to indicate
</span></span></span><span class="line"><span class="cl"><span class="c1">// that we just need to re-render what changed since the last frame.
</span></span></span><span class="line"><span class="cl"><span class="c1">// What&#39;s shown on the screen buffer is not in our RAM, but actually within the display itself.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Only the changed part of the screen will be updated.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">let</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">MinimalSoftwareWindow</span>::<span class="n">new</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">RepaintBufferType</span>::<span class="n">ReusedBuffer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">const</span><span class="w"> </span><span class="no">DISPLAY_WIDTH</span>: <span class="kt">usize</span> <span class="o">=</span><span class="w"> </span><span class="mi">320</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">line_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">slint</span>::<span class="n">platform</span>::<span class="n">software_renderer</span>::<span class="n">Rgb565Pixel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="no">DISPLAY_WIDTH</span><span class="p">];</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hal</span>::<span class="n">Display</span>::<span class="n">new</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// ... rest of initialization ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">loop</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">    </span><span class="n">window</span><span class="p">.</span><span class="n">draw_if_needed</span><span class="p">(</span><span class="o">|</span><span class="n">renderer</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">renderer</span><span class="p">.</span><span class="n">render_by_line</span><span class="p">(</span><span class="n">DisplayWrapper</span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">display</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">display</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">line_buffer</span>: <span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">line_buffer</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>注意：根据我们的经验，使用同步 <code>DrawTarget::fill_contiguous</code> 函数会比较慢。如果您的设备能够使用 DMA，您可以通过使用两个行缓冲区来获得更好的性能：一个缓冲区使用 CPU 渲染，另一个缓冲区使用 DMA 异步传输到屏幕。</p>
<h2 id="示例实现">示例实现</h2>
<p>Slint 附带的示例使用了名为 <code>mcu-board-support</code> 的辅助板块。它为某些 MCU 提供了 Platform 特性的实现，以及对触摸输入和系统定时器的支持。</p>
<p>您可以在我们的 Git 仓库中找到该 crate，网址是</p>
<p><a href="https://github.com/slint-ui/slint/tree/master/examples/mcu-board-support" target="_blank" rel="noopener noreffer ">https://github.com/slint-ui/slint/tree/master/examples/mcu-board-support</a></p>
<p>如果您的 MCU 是受欢迎的板子，那么您可以在 <code>Cargo.toml</code> 中将其指定为我们 Git 仓库中的依赖项。</p>
<p>如需完整模板，请查看我们的 <a href="https://github.com/slint-ui/slint-mcu-rust-template" target="_blank" rel="noopener noreffer "><code>Slint Bare Metal Microcontroller Rust</code></a> 模板。</p>
<p>我们还有一个适合小屏幕的打印机演示版本，即 <a href="https://github.com/slint-ui/slint/tree/master/examples/printerdemo_mcu" target="_blank" rel="noopener noreffer "><code>MCU 打印机演示</code></a>。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2023-11-22</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/" data-title="Slint文档小译"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/" data-title="Slint文档小译"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/" data-title="Slint文档小译"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://dinduck.github.io/posts/slint%E6%96%87%E6%A1%A3%E5%B0%8F%E8%AF%91/" data-title="Slint文档小译"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/c%CE%BBash/" class="prev" rel="prev" title="CλaSH"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>CλaSH</a>
            <a href="/posts/nixos%E5%AE%89%E8%A3%85/" class="next" rel="next" title="NixOS安装">NixOS安装<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.121.1">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2022 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">Lucky Ling</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
